generator client {
        provider     = "prisma-client"
        output       = "../src/generated/prisma"
        // CJS required for NestJS compatibility (Prisma 7 defaults to ESM)
        moduleFormat = "cjs"
}

datasource db {
        provider = "postgresql"
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum Role {
        CUSTOMER
        ADMIN
}

model User {
        id        String   @id @default(cuid())
        email     String   @unique
        password  String
        firstName String?  @map("first_name")
        lastName  String?  @map("last_name")
        role      Role     @default(CUSTOMER)
        isActive  Boolean  @default(true) @map("is_active")
        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        refreshTokens RefreshToken[]
        addresses     Address[]
        cart          Cart?
        orders        Order[]
        couponUsages  CouponUsage[]
        reviews       Review[]

        @@map("users")
}

model RefreshToken {
        id          String   @id @default(cuid())
        tokenHash   String   @map("token_hash")
        tokenFamily String   @map("token_family")
        userId      String   @map("user_id")
        userAgent   String?  @map("user_agent")
        ipAddress   String?  @map("ip_address")
        expiresAt   DateTime @map("expires_at")
        isRevoked   Boolean  @default(false) @map("is_revoked")
        createdAt   DateTime @default(now()) @map("created_at")

        user User @relation(fields: [userId], references: [id], onDelete: Cascade)

        @@index([userId])
        @@index([tokenFamily])
        @@map("refresh_tokens")
}

enum AddressType {
        SHIPPING
        BILLING
}

model Address {
        id        String      @id @default(cuid())
        userId    String      @map("user_id")
        type      AddressType @default(SHIPPING)
        isDefault Boolean     @default(false) @map("is_default")

        fullName   String  @map("full_name")
        phone      String
        street     String
        city       String
        region     String?
        postalCode String  @map("postal_code")
        country    String  @default("PL")

        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        user User @relation(fields: [userId], references: [id], onDelete: Cascade)

        @@index([userId])
        @@map("addresses")
}

// ============================================
// CATALOG
// ============================================

model Category {
        id                 String  @id @default(cuid())
        name               String
        slug               String  @unique
        description        String?
        imageUrl           String? @map("image_url")
        cloudinaryPublicId String? @map("cloudinary_public_id")

        // Hierarchical structure (self-relation)
        parentId String?    @map("parent_id")
        parent   Category?  @relation("CategoryTree", fields: [parentId], references: [id], onDelete: SetNull)
        children Category[] @relation("CategoryTree")

        // Soft delete & ordering
        isActive  Boolean @default(true) @map("is_active")
        sortOrder Int     @default(0) @map("sort_order")

        // Timestamps
        createdAt DateTime  @default(now()) @map("created_at")
        updatedAt DateTime  @updatedAt @map("updated_at")
        products  Product[]

        @@index([parentId])
        @@map("categories")
}

model Product {
        id          String  @id @default(cuid())
        name        String
        slug        String  @unique
        description String?

        // Pricing - Use Decimal, NOT @db.Money (causes rounding issues)
        price        Decimal  @db.Decimal(10, 2) // Max: 99,999,999.99
        comparePrice Decimal? @map("compare_price") @db.Decimal(10, 2)

        // Inventory
        sku               String? @unique // Stock Keeping Unit
        stock             Int     @default(0)
        reservedStock     Int     @default(0) @map("reserved_stock")
        lowStockThreshold Int     @default(5) @map("low_stock_threshold")

        // Relations
        categoryId String         @map("category_id")
        category   Category       @relation(fields: [categoryId], references: [id])
        images     ProductImage[]

        // Status
        isActive      Boolean  @default(true) @map("is_active")
        isFeatured    Boolean  @default(false) @map("is_featured")
        averageRating Decimal? @map("average_rating") @db.Decimal(2, 1)
        reviewCount   Int      @default(0) @map("review_count")

        // Timestamps
        createdAt      DateTime        @default(now()) @map("created_at")
        updatedAt      DateTime        @updatedAt @map("updated_at")
        stockMovements StockMovement[]
        cartItems      CartItem[]
        orderItems     OrderItem[]
        reviews        Review[]

        @@index([categoryId]) // FK index for relation queries
        @@index([isActive, isFeatured]) // Compound index for filtered listings
        @@map("products")
}

model ProductImage {
        id                 String  @id @default(cuid())
        url                String
        alt                String? // Accessibility
        cloudinaryPublicId String? @map("cloudinary_public_id")
        sortOrder          Int     @default(0) @map("sort_order")

        productId String  @map("product_id")
        product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

        createdAt DateTime @default(now()) @map("created_at")

        @@index([productId]) // FK index for relation queries
        @@map("product_images")
}

// ============================================
// INVENTORY
// ============================================

enum StockMovementType {
        ADJUSTMENT // Manual admin adjustment
        RESERVATION // Reserved for cart/checkout
        RELEASE // Released from abandoned cart
        SALE // Sold (order completed)
        RETURN // Returned by customer
        RESTOCK // New inventory received
}

model StockMovement {
        id        String  @id @default(cuid())
        productId String  @map("product_id")
        product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

        type     StockMovementType
        quantity Int // Positive = increase, Negative = decrease
        reason   String? // optional explanation

        // Snapshot at time of movement (for audit)
        stockBefore Int @map("stock_before")
        stockAfter  Int @map("stock_after")

        // Who made this change
        userId String? @map("user_id") // Null for system actions

        createdAt DateTime @default(now()) @map("created_at")

        @@index([productId])
        @@index([createdAt])
        @@map("stock_movements")
}

// ============================================
// CART
// ============================================

model Cart {
        id     String @id @default(cuid())
        userId String @unique @map("user_id") // One cart per user
        user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

        items CartItem[]

        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        @@map("carts")
}

model CartItem {
        id     String @id @default(cuid())
        cartId String @map("cart_id")
        cart   Cart   @relation(fields: [cartId], references: [id], onDelete: Cascade)

        productId String  @map("product_id")
        product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

        quantity Int

        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        @@unique([cartId, productId]) // One entry per product per cart
        @@index([cartId])
        @@index([productId])
        @@map("cart_items")
}

// ============================================
// ORDERS
// ============================================

enum OrderStatus {
        PENDING // Order created, awaiting payment
        CONFIRMED // Payment received
        PROCESSING // Being prepared/packed
        SHIPPED // Handed to carrier
        DELIVERED // Customer received it
        CANCELLED // Cancelled by customer or admin
}

model Order {
        id          String      @id @default(cuid())
        orderNumber String      @unique @map("order_number") // Human-readable "ORD-20260202-XXXX"
        userId      String      @map("user_id")
        user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
        status      OrderStatus @default(PENDING)

        // Address snapshots (copied at checkout, not a FK reference)
        // Why snapshots? If user edits/deletes address later, order history stays intact
        shippingFullName   String  @map("shipping_full_name")
        shippingPhone      String  @map("shipping_phone")
        shippingStreet     String  @map("shipping_street")
        shippingCity       String  @map("shipping_city")
        shippingRegion     String? @map("shipping_region")
        shippingPostalCode String  @map("shipping_postal_code")
        shippingCountry    String  @map("shipping_country")
        shippingMethodName String? @map("shipping_method_name")

        // Money fields - Decimal avoids floating point errors (e.g., 0.1 + 0.2 !== 0.3)
        subtotal       Decimal @db.Decimal(10, 2) // Sum of all lines total
        shippingCost   Decimal @default(0) @map("shipping_cost") @db.Decimal(10, 2)
        tax            Decimal @default(0) @db.Decimal(10, 2)
        discountAmount Decimal @default(0) @map("discount_amount") @db.Decimal(10, 2)
        couponCode     String? @map("coupon_code")
        total          Decimal @db.Decimal(10, 2) // subtotal + shipping + tax

        // Optional notes
        notes      String? // Customer notes ("leave at door")
        adminNotes String? @map("admin_notes") // Internal staff notes

        items OrderItem[]

        createdAt   DateTime     @default(now()) @map("created_at")
        updatedAt   DateTime     @updatedAt @map("updated_at")
        couponUsage CouponUsage?
        payment     Payment?

        @@index([userId]) // Find all orders for a user
        @@index([status]) // Filter orders by status (admin dashboard)
        @@index([orderNumber]) // Fast lookup by order number
        @@map("orders")
}

model OrderItem {
        id      String @id @default(cuid())
        orderId String @map("order_id")
        order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

        productId String?  @map("product_id")
        product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

        // Product snapshot at time of purchase (prices/names can change later)
        productName     String  @map("product_name")
        productSku      String? @map("product_sku")
        productImageUrl String? @map("product_image_url")

        quantity  Int
        unitPrice Decimal @map("unit_price") @db.Decimal(10, 2) // Price per unit at checkout
        lineTotal Decimal @map("line_total") @db.Decimal(10, 2) // unitPrice * quantity

        createdAt DateTime @default(now()) @map("created_at")

        @@index([orderId]) // Get all items for an order
        @@index([productId]) // Find orders containing a product
        @@map("order_items")
}

// ============================================
// COUPONS
// ============================================

enum CouponType {
        PERCENTAGE // e.g. 10% off
        FIXED_AMOUNT // e.g. $20 off
}

model Coupon {
        id          String     @id @default(cuid())
        code        String     @unique // "SUMMER2026" - customer enters this
        description String? // Internal note for admins
        type        CouponType // How the discount is calculated
        value       Decimal    @db.Decimal(10, 2) // 10.00 = 10% or $10 depending on type

        // Rules - all optional, null = no limit
        minimumOrderAmount Decimal? @map("minimum_order_amount") @db.Decimal(10, 2) // Min cart subtotal
        maximumDiscount    Decimal? @map("maximum_discount") @db.Decimal(10, 2) // Cap for % coupons
        usageLimit         Int?     @map("usage_limit") // Total uses allowed
        usageLimitPerUser  Int?     @map("usage_limit_per_user") // Uses per customer
        usageCount         Int      @default(0) @map("usage_count") // Current total uses

        // Validity window
        validFrom  DateTime @map("valid_from")
        validUntil DateTime @map("valid_until")
        isActive   Boolean  @default(true) @map("is_active")

        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        usages CouponUsage[]

        @@map("coupons")
}

model CouponUsage {
        id       String @id @default(cuid())
        couponId String @map("coupon_id")
        coupon   Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)
        userId   String @map("user_id")
        user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
        orderId  String @unique @map("order_id") // One coupon per order
        order    Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

        discountAmount Decimal @map("discount_amount") @db.Decimal(10, 2) // Actual $ saved

        createdAt DateTime @default(now()) @map("created_at")

        @@index([couponId])
        @@index([userId])
        @@map("coupon_usages")
}

// ============================================
// SHIPPING
// ============================================

model ShippingMethod {
        id          String  @id @default(cuid())
        name        String  @unique // "Standard Shipping", "Express"
        description String? // "Delivered in 3-5 business days"

        // Pricing
        basePrice             Decimal  @map("base_price") @db.Decimal(10, 2) // Flat rate cost
        freeShippingThreshold Decimal? @map("free_shipping_threshold") @db.Decimal(10, 2) // Orders above this = free

        // Display
        estimatedDays String  @map("estimated_days") // "3-5 business days"
        sortOrder     Int     @default(0) @map("sort_order")
        isActive      Boolean @default(true) @map("is_active")

        // Timestamps
        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        @@map("shipping_methods")
}

// ============================================
// REVIEWS
// ============================================

enum ReviewStatus {
        PENDING // Awaiting admin moderation
        APPROVED // Visible to public
        REJECTED // Hidden, with admin note
}

model Review {
        id        String  @id @default(cuid())
        userId    String  @map("user_id")
        user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
        productId String  @map("product_id")
        product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

        // Review content
        rating  Int // 1-5 stars (validated in DTO, not DB)
        title   String? // Optional headline: "Great product!"
        comment String // Review body text (min length validated in DTO)

        // Moderation
        status    ReviewStatus @default(PENDING)
        adminNote String?      @map("admin_note") // Reason for rejection

        // Timestamps
        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        @@unique([userId, productId]) // One review per user per product
        @@index([productId]) // Get all reviews for a product
        @@index([userId]) // Get all reviews by a user
        @@index([status]) // Filter by moderation status
        @@map("reviews")
}

// ============================================
// PAYMENTS
// ============================================

enum PaymentStatus {
        PENDING // Intent created, awaiting customer action
        SUCCEEDED // Payment confirmed by Stripe
        FAILED // Payment declined or failed
        REFUND_PENDING // Refund initiated, awaiting Stripe confirmation
        REFUNDED // Fully refunded (confirmed by webhook)
        PARTIALLY_REFUNDED // Partially refunded (confirmed by webhook)
}

model Payment {
        id                    String        @id @default(cuid())
        orderId               String        @unique @map("order_id")
        order                 Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
        stripePaymentIntentId String        @unique @map("stripe_payment_intent_id")
        status                PaymentStatus @default(PENDING)
        amount                Decimal       @db.Decimal(10, 2)
        currency              String        @default("pln")

        // Refund tracking
        refundedAmount Decimal @default(0) @map("refunded_amount") @db.Decimal(10, 2)
        stripeRefundId String? @map("stripe_refund_id")
        refundReason   String? @map("refund_reason")

        // Failure tracking (populated from Stripe on failure)
        failureCode    String? @map("failure_code")
        failureMessage String? @map("failure_message")

        createdAt DateTime @default(now()) @map("created_at")
        updatedAt DateTime @updatedAt @map("updated_at")

        @@index([orderId])
        @@index([stripePaymentIntentId])
        @@index([status])
        @@index([createdAt]) // For abandoned payment cleanup queries
        @@map("payments")
}

// Tracks processed webhook events to prevent duplicate processing.
// Stripe can deliver the same event multiple times (5-10% retry rate).
model WebhookEvent {
        id          String   @id // Use Stripe event ID (evt_xxx) as PK â€” no cuid()
        type        String // e.g., "payment_intent.succeeded"
        processedAt DateTime @default(now()) @map("processed_at")

        @@map("webhook_events")
}
